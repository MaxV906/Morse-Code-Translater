// TO DO:
// Implement morse code to ascii function in the Morse Translater
// Implement tests for morse to ascii translation


enum Direction {
    Left,
    Right
}

struct Node {
    value: Option<char>,
    left: Option<Box<Node>>,
    right: Option<Box<Node>>
}

impl Node {

    // Binary tree node constructor
    fn new(value: Option<char>) -> Node {
        Node {
            value,
            left: None,
            right: None
        }
    }

    // This function inserts values and creates new nodes on the left/right branch. It will help implement the binary tree for morse code translation easier.
    fn insert(&mut self, value: Option<char>, mut directions: Vec<Direction>) {

        if directions.is_empty() { // Checks if the direction vector is empty
            self.value = value; // Inserts the value
            return // Exits the function
        }

        let d = directions.remove(0); // Removes the first direction in the vector and stores it

        match d {
            Direction::Left => { // Checks if the removed direction is left
                if self.left.is_none() { // Checks if left node exists.
                    self.left = Some(Box::new(Node::new(None))); // If it isn't, it creates a node
                    self.left.as_mut().unwrap().value = value; // And stores a value in it
                    return // Exists the function
                }

                self.left.as_mut().unwrap().insert(value, directions); // If it does, it passes the value and direction onto the next left Node
            },

            Direction::Right => { // Does the same thing, just for the right node
                if self.right.is_none() {
                    self.right = Some(Box::new(Node::new(None)));
                    self.right.as_mut().unwrap().value = value;
                    return
                }

                self.right.as_mut().unwrap().insert(value, directions);
            }
        }


    }


}


pub enum Translation {
    ASCII,
    CODE
}

pub enum Error {
    MessageNotSet,
    NotValidChar
}

pub struct Morse {
    code: Vec<String>,
    tree: Node,
    message: String
}

impl Morse {
   
    // Morse code translater constructor
    pub fn new() -> Morse {

        Morse {
            code: Morse::make_vector(), // Inserts ascii to code vector
            tree: Morse::make_binary_tree(), // Temporarily makes a empty binary tree node
            message: String::new() // Sets an empty string as a message
        }

    }

    // Sets the message for translation
    pub fn set_message(&mut self, message: &str) {

        if !self.message.is_empty() {
            self.message.clear();
        }
        self.message = String::from(message);

    }

    // Translates and returns a result
    pub fn translate(&self, translation: Translation) -> Result<String, Error> {

        match translation {
            Translation::ASCII => {
                return Ok("Test".to_string()); // Will be implemented properly later
            },
            Translation::CODE => {
                return self.translate_to_code(); // Result from ascii to code translation
            } 
        }

    }

    // Translates ascii to code
    fn translate_to_code(&self) -> Result<String, Error> {

        if self.message.is_empty() { // Checks if message is set
            return Err(Error::MessageNotSet); // If it's not, returns Error (MessageNotSet)
        }
        
        let binding = self.message.clone().to_uppercase(); // Clones the message and makes it uppercase so it doesn't affect the original message
        let message = binding.chars(); // Turns it into an array of characters
        let mut translation: String = String::new(); // Sets up a new string that will hold the translated message

        for c in message { // For every character in the message

            let c_code = c as usize; // Converts the character into it's ascii code

            if c.is_whitespace() { // Checks if the character is whitespace
                if c == ' ' { // Checks if it's a space character

                    translation.push_str("  "); // If it is, it pushes 2 space characters to seperate the words
                    continue; // Starts the loop again
                }
            }

            let i = c_code - 65; // Subtracts 65 from the code because 65 is ascii code for the character 'A'. That gives us the index that we can use in the Morse Code Vector generated by make_vector() function

            if i <= 90 { // Checks if the character is in range from A-Z
                translation.push_str(format!("{} ", self.code[i]).as_str()); // Pushes the morse code equivelent of the character and a space character to seperate letters
                continue; // Starts the loop again
            }

            return Err(Error::NotValidChar); // If all else fails, returns NotValidChar error

        }

        translation.truncate(translation.trim_end().len()); // Removes all the space characters at the end of the translation string
       
        return Ok(translation); // Returns the translation string as a result
        
    }

    // Creates a vector containing morse code for each character

    fn make_vector() -> Vec<String> {

        return vec![
            String::from(".-"), // A
            String::from("-..."), // B
            String::from("-.-."), // C
            String::from("-.."), // D
            String::from("."), // E
            String::from("..-."), // F
            String::from("--."), // G
            String::from("...."), // H
            String::from(".."), // I
            String::from(".---"), // J
            String::from("-.-"), // K
            String::from(".-.."), // L
            String::from("--"), // M
            String::from("-."), // N
            String::from("---"), // O
            String::from(".--."), // P
            String::from("--.-"), // Q
            String::from(".-."), // R
            String::from("..."), // S
            String::from("-"), // T
            String::from("..-"), // U
            String::from("...-"), // V
            String::from(".--"), // W
            String::from("-..-"), // X
            String::from("-.--"), // Y
            String::from("--..") // Z
        ];

    }

    // Creates a binary tree
    fn make_binary_tree() -> Node {
        let mut root = Node::new(None);

        root.insert(Some('E'), vec![Direction::Left]);
        root.insert(Some('T'), vec![Direction::Right]);

        return root;
    }
 
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn ascii_to_code_test() {
        let mut mst: Morse = Morse::new();
        mst.set_message("SOS");

        match mst.translate(Translation::CODE) {
            Ok(res) => {
                assert_eq!(res, String::from("... --- ..."));
            },

            Err(_) => {
                assert!(false);
            }
        }

        mst.set_message("S O S");

        match mst.translate(Translation::CODE) {
            Ok(res) => {
                assert_eq!(res, String::from("...   ---   ..."));
            },

            Err(_) => {
                assert!(false);
            }
        }
    }

    #[test]
    fn binary_tree_test() {
        let mut mst: Morse = Morse::new();

        if let Some(c) = mst.tree.left.unwrap().value {
            assert_eq!(c, 'E');
        }

        if let Some(c) = mst.tree.right.unwrap().value {
            assert_eq!(c, 'T');
            return
        }

        assert!(false);
    }
    
}
